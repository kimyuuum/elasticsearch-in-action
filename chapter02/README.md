# 02장 시작해 보기

### Elasticsearch 요청과 응답의 흐름

1. 키바나는 필수 입력 매개변수를 사용해 이 요청을 elasticsearch 서버에 전송한다.
2. 요청을 받으면 서버는
    1. 도큐먼트 데이터를 분석해 좀 더 빠른 접근을 위해 역인덱스에 저장한다.
    2. 새 인덱스를 생성하고 도큐먼트를 저장한다.
    3. 필요한 매핑 및 데이터 스키마를 생성한다.
    4. 클라이언트에게 응답을 다시 보낸다.
3. 키바나는 응답을 수신하고 사용자를 위해 오른쪽 패널에 이 응답을 표시한다.

 

- PUT메서드
    - PUT은 리소스를 생성하기 위해 서버에 요청을 보내고 있음을 나타내는 HTTP동사다.
- books 인덱스
    - URL의 books부분을 인덱스라고 부른다. 모든 book document를 수집하기 위한 버킷이다.
    - 관계형 데이터베이스의 테이블과 유사하다.
    - 이 books인덱스에는 book도큐먼트만 저장된다.
- _doc 엔드포인트
    - 엔드포인트는 수행중인 작업과 연결된 경로의 상수 부분이다.
    - 7버전 이하의 elasticsearch에서는 _doc의 위치가 도큐먼트 매핑 유형으로 채워졌다.
    - 매핑 유형은 더 이상 사용되지 않으며 _doc는 이를 URL의 상수 엔드포인트경로로 대체했다.
- 도큐먼트 ID
    - URL에서 숫자 1은 도큐먼트 ID를 나타낸다.
    - 데이터베이스 레코드의 기본 키와 같다.
    - 사용자는 이 식별자를 사용해 도큐먼트를 검색한다.
- 요청 본문
    - 요청 본문은 책 데이터를 JSON으로 표현한 것이다.
    - elasticsearch에서는 모든 데이터가 JSON 형식의 도큐먼트로 전송될 것으로 예상한다.
    - JSON의 중첩 객체 형식으로 전송된 중첩 객체도 지원한다.

### 도큐먼트 타입과 _doc 엔드포인트

elasticsearch 7.x 버전 이전에는 인덱스가 여러 타입의 엔티티를 보유할 수 있었다. (ex : books 인덱스는 책 뿐만 아니라, 서평, 책 판매, 서점 등도 보유할 수 있었다)

단일 인덱스에 모든 타입의 도큐먼트가 있어 복잡해졌고 필드 매핑이 여러 타입에 걸쳐 공유돼 오류와 데이터 희소성이 발생했다. 타입 및 관리 문제를 방지하기 위해 elastic은 이 타입을 제거하기로 결정했다.

이전 버전에서는 타입이 포함된 호출 URL은 index_name/type/id와 같았다.

이 타입은 버전 7.x 이상부터 사용되지 않는다. 

이제 인덱스는 단 하나의 타입에만 사용될 것으로 기대하며, _doc는 URL에 포함된 엔드포인트다. 

Elasticsearch는 데이터를 인덱싱하기 전에 데이터 스키마를 정의하도록 요청하지 않았다.

관계형 데이터베이스와 달리 elasticsearch는 사전에 스키마를 생성하도록 요구하지 않으며, 인덱싱하는 첫 도큐먼트에서 스키마를 파생시킨다. 또한 인덱스도 생성한다.

- 결론적으로 Elasticsearch는 개발 중에 방해 요소를 좋아하지 않으며, 모범 사례는 프로덕션 환경에서는 사전에 자체 스키마를 생성하는 것이다.

### 데이터 검색

`count` 는 `GET books1,books2/_count` 와 같이 쉼표로 구분된 인덱스를 추가해 동일한 API를 사용해 여러 인덱스에서 동시에 가져올수도 있다.

`GET _count`를 호출해 모든 인덱스의 도큐먼트 개수를 가져올수도 있다.

`ids 쿼리를 사용해 여러 도큐먼트 가져오기`

```json
GET books/_search
{
    "_source": false, // 불필요한 document 소스를 제거하고 검색할 수 있다.
    "query": {
        "ids": {
            "values": [1,2,3] //document 배열을 지정한다.
        }
    }
}

#response
"hits" : [] //응답은 총 3건의 도큐먼트를 반환한다.
```

`_search` 는 `match_all` 이라는 특수 쿼리의 짧은 형식이다.

### 풀텍스트 검색

elasticsearch는 풀텍스트 쿼리라고 부르는 비구조화된 텍스트를 검색하는 검색 기능을 제공한다.

`match` 쿼리 : 특정 저자의 책 검색

```json
GET books/_search
{
    "query": {
        "match": {
          "FIELD": "TEXT" //          "author": "joshua"
        }
    }
}
```

match쿼리는 비구조화된 텍스트나 풀텍스트에서 단어를 검색하는데 도움된다.

```json
GET books/_search
{
    "query": {
        "prefix": {
          "author": "josh"
        }
    }
}

//prefix 는 텀 수준 쿼리이므로 쿼리 값은 소문자여야 한다.
```

operator

- operator : and 와 같은 형식으로 해야 a or b로 a b 타이틀에 띄어쓰기가 있을 때 검색하지 않는다.

`_bulk API`

도큐먼트를 동시에 인덱싱 할 수 있는 API이다.

여러 도큐먼트를 인덱싱할 때 키바나 또는 cURL을 사용해 _bulk API를 실행가능하다.

벌크 작업은 기존 데이터를 덮어쓴다.

`multi match`

```json
GET books/_search
{
    "query": {
        "multi_match": {
          "query": "Java",
          "fields": ["title^3", "synopsis"] //^ : 캐럿은 부스트되는 필드와 숫자를 표시한다.
        }
    }
}
```

두 필드에 걸쳐 “Java”라는 단어를 검색한다.

만약 title필드에 가중치를 더 두고싶다면 boosting기능을 사용하면 된다.

- score가 관련성 점수를 나타낸다.

`match_pharse`

문구 검색. 특정 문구가 있는 모든 책을 찾는 것처럼 주어진 순서로 정확히 일련의 단어를 검색하고 싶을 때 사용한다.

`slop`

- match_parse에 slop 매개변수를 설정하면 매개변수를 검색 시 구문에 누락된 단어 수를 나타내는 양의 정수다.
- slop이 2면 쿼리가 실행될 때 최대 2개의 단어가 누락되거나 순서대로 정렬되지 않을 수 있음을 의미한다.

### 텀 수준 쿼리

구조화된 데이터를 지원하기 위해 별도의 쿼리 유형인 텀 수준 쿼리가 있다.

숫자, 날짜, 범위, IP주소 등은 구조화된 텍스트 범주에 속한다.

구조화되지 않은 데이터는 분석되는 반면, 구조화된 필드는 있는 그대로 저장된다.

- 텀 수준 쿼리는 이진 출력을 만든다.
- 쿼리가 조건과 일치하면 결과를 가져온다.
- 쿼리는 도큐먼트가 얼마나 잘 일치하는지를 고려하지 않는다.
- 쿼리에 일치 항목이 있는지 여부에 집중한다.
- 관련성을 고려하지 않으므로 텀 수준 쿼리는 관련성 점수를 생성하지 않는다.

```json
GET books/_search
{
	"_source" : ["title", "edition"], // 이 응답 도큐먼트에서는 2개의 필드만 반환
  "query": {
    "term": { //쿼리를 텀 수준 쿼리로 선언
      "edition": { // 필드와 값을 검색 조건으로 제공
        "value": 3
      }
    }
  }
}
```

### range 쿼리

range는 범위와 일치하는 결과를 가져온다.

```json
GET books/_search
{
  "query": {
    "range": {
      "amazon_rating": {
        "gte": 4.5,
        "lte": 5
      }
    }
  }
}
```

### compound 쿼리

복잡하고 정교한 쿼리를 생성하는 메커니즘을 제공한다.

- bool
- constant_score
- function_score
- boosting
- dis_max

bool쿼리가 가장 일반적으로 많이 사용된다.

```json
GET books/_search
{
  "query": {
    "bool": {
      "must": [        {        }      ], // 도큐먼트와 조건이 일치해야 한다.
      "must_not" : [{}], // 조건이 일치하지 않아야 한다. (점수 기여 없음)
      "should" : [{}], // 쿼리가 일치해야 한다.
      "filter" : [{}] // 쿼리가 일치해야 한다. (점수 기여 없음)
    }
  }
}
```

`must`

must절은 쿼리의 검색 조건이 도큐먼트와 일치해야 함을 의미한다.

긍정적인 일치는 관련성 점수를 높인다. 

가능한 한 많은 리프 쿼리를 사용해 must절을 작성한다.

`must_not`

must_not절에서 조건은 도큐먼트와 일치하지 않아야 한다.

이 절은 점수에 영향을 미치지 않는다.

`should`

should절에 정의된 조건이 반드시 일치해야 하는 것은 아니다.

그러나 일치하는 경우 관련성 점수가 올라간다.

`filter`

filter절에서 조건은 must절과 유사하게 도큐먼트와 일치해야 한다. 유일한 차이점은 점수가 filter 절과 관련이 없다는 것이다.

### must절

```json
GET books/_search
{
  "query": {
    "bool": { // bool쿼리
      "must": [ // 도큐먼트가 조건에 일치해야 한다.
        {
          "match": {
            "author": "Joshua Bloch" // 해당 저자가 저술한 책과 일치하는 쿼리
          }
        },
        {
          "match_phrase": { //필드의 문구를 검색하는 두 번째 쿼리
            "synopsis": "best Java programming books"
          }
        }
      ]
    }
  }
}
```

### should 절

should절은 OR연산자처럼 동작한다.

검색어가 should 쿼리와 일치하면 관련성 점수가 올라간다.

단어가 일치하지 않더라도 실패하지 않으며 해당 조건은 무시된다.

**should절의 목적은 결과에 영향을 주기보다는 관련성 점수를 높이는 데 더 가깝다.**

### filter절

```json
GET books/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "author": "Joshua"
          }
        }
      ],
      "must_not": [
        {
          "range": {
            "amazon_rating": {
              "lt": 4.7
            }
          }
        }
      ],
      "should": [
        {
          "match": {
            "tags": "Software"
          }
        }
      ],
      "filter": [
        {
          "range": {
            "release_date": {
              "gte": "2015-01-01" // filter조건과 일치하지 않는 결과는 제외된다.
            }
          }
        }
      ]
    }
  }
}
```

### 집계

```json
GET books/_search // 집계를 위해 동일한 search 엔드포인트 사용
{
  "aggs": { // 수행하려는 작업의 유형
    "avg_rating": { // 출력 필드에 주어진 맞춤형 이름
      "avg": { //평균 메트릭을 계산하려 한다
        "field": "amazon_rating" // 위 필드에서 집계를 실행한다.
      }
    }
  }
}

GET covid/_search
{
  "size": 0, 
  "aggs": {
    "critical_patients": { // 집계 요청을 위한 사용자 정의 이름
      "sum": {
        "field": "critical" // 집계 적용 필드
      }
    }
  }
}

GET covid/_search
{
  "size": 0, 
  "aggs": {
    "all_stats": {
      "stats": { // status 쿼리는 다섯가지 핵심 메트릭을 모두 한 번에 반환한다.
        "field": "deaths"
      }
    }
  }
}
```

### 버킷 집계

버킷 집계는 데이터를 다양한 그룹이나 버킷으로 분리한다.

예를 들어 연령층별 성인 그룹 조사, 리뷰 평점별 영화 등등 그룹을 버킷에 추가할 수 있다.

기본적으로 최소 20개 이상의 집계를 제공한다.

`histogram`

모든 도큐먼트를 검토해 숫자 값을 나타내는 버킷 목록을 생성한다.

### 요약

- elasticsearch는 데이터 인덱싱을 위한 일련의 도큐먼트 API를 제공한다.
- 단일 도큐먼트 API를 사용해 도큐먼트를 검색하려면 ID가 있는 인덱스에 대해 GET명령을 실행한다.
- 여러 도큐먼트를 검색하려면 도큐먼트 식별자를 사용할 수 있는 경우 ids쿼리를 사용할 수 있다.
- elasticsearch는 기본 및 고급 쿼리를 포함해 광범위한 검색 API세트를 제공한다.
- 풀텍스트 쿼리는 비구조화된 데이터를 검색해 관련 도큐먼트를 찾는다.
- term쿼리는 숫자 및 날짜와 같은 구조화된 데이터를 검색해 일치하는 도큐먼트를 찾는다.
- 복합 쿼리를 사용하면 리프 쿼리를 컴파일하고 고급 쿼리 집합을 만들 수 있다.
- 복합 쿼리 중 하나인 bool쿼리는 여러 절이 포함된 고급 쿼리를 생성하는 메커니즘을 제공한다.
- 검색은 주어진 조건에 따라 일치하는 도큐먼트를 찾는 반면, 분석을 사용하면 통계 기능 제공이 된다.
- 메트릭 집계는 max, min, sum, avg와 같은 일반적인 집계 결과를 가져온다.
- 버킷팅 집계는 특정 조건에 따라 도큐먼트를 다양한 그룹으로 분리한다.